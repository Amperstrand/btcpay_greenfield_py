# coding: utf-8

"""
    BTCPay Greenfield API

    A full API to use your BTCPay Server

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from pydantic import Field
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class CreateCrowdfundAppRequest(BaseModel):
    """
    CreateCrowdfundAppRequest
    """ # noqa: E501
    app_name: Optional[StrictStr] = Field(default=None, description="The name of the app (shown in admin UI)", alias="appName")
    title: Optional[StrictStr] = Field(default=None, description="The title of the app (shown to the user)")
    description: Optional[StrictStr] = Field(default=None, description="The description of the app (shown to the user)")
    enabled: Optional[StrictBool] = Field(default=True, description="Determines if the app is enabled to be viewed by everyone")
    enforce_target_amount: Optional[StrictBool] = Field(default=False, description="Will not allow contributions over the set target amount", alias="enforceTargetAmount")
    start_date: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="A unix timestamp in seconds", alias="startDate")
    end_date: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="A unix timestamp in seconds", alias="endDate")
    target_currency: Optional[StrictStr] = Field(default=None, description="Target currency for the crowdfund. Defaults to the currency used by the store if not specified", alias="targetCurrency")
    target_amount: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Target amount for the crowdfund", alias="targetAmount")
    custom_css_link: Optional[StrictStr] = Field(default=None, description="Link to a custom CSS stylesheet to be used in the app", alias="customCSSLink")
    main_image_url: Optional[StrictStr] = Field(default=None, description="URL for image to be used as a cover image for the app", alias="mainImageUrl")
    embedded_css: Optional[StrictStr] = Field(default=None, description="Custom CSS to embed into the app", alias="embeddedCSS")
    perks_template: Optional[StrictStr] = Field(default=None, description="YAML template of perks available in the app", alias="perksTemplate")
    notification_url: Optional[StrictStr] = Field(default=None, description="Callback notification url to POST to once when invoice is paid for and once when there are enough blockchain confirmations", alias="notificationUrl")
    tagline: Optional[StrictStr] = Field(default=None, description="Tagline for the app (shown to the user)")
    disqus_shortname: Optional[StrictStr] = Field(default=None, description="Disqus shortname to used for the app. Enables Disqus functionality if set.", alias="disqusShortname")
    sounds_enabled: Optional[StrictBool] = Field(default=False, description="Enables sounds on new contributions if set to true", alias="soundsEnabled")
    animations_enabled: Optional[StrictBool] = Field(default=False, description="Enables background animations on new contributions if set to true", alias="animationsEnabled")
    reset_every_amount: Optional[Union[StrictFloat, StrictInt]] = Field(default=1, description="Contribution goal reset frequency amount. Must be used in conjunction with resetEvery and startDate.", alias="resetEveryAmount")
    reset_every: Optional[StrictStr] = Field(default='Never', description="Contribution goal reset frequency. Must be used in conjunction with resetEveryAmount and startDate.", alias="resetEvery")
    display_perks_value: Optional[StrictBool] = Field(default=False, description="Displays values of perks if set to true", alias="displayPerksValue")
    sort_perks_by_popularity: Optional[StrictBool] = Field(default=False, description="Sorts perks by popularity if set to true", alias="sortPerksByPopularity")
    sounds: Optional[List[StrictStr]] = Field(default=None, description="Array of custom sounds to use on new contributions")
    animation_colors: Optional[List[StrictStr]] = Field(default=None, description="Array of custom HEX colors to use for background animations on new contributions", alias="animationColors")
    __properties: ClassVar[List[str]] = ["appName", "title", "description", "enabled", "enforceTargetAmount", "startDate", "endDate", "targetCurrency", "targetAmount", "customCSSLink", "mainImageUrl", "embeddedCSS", "perksTemplate", "notificationUrl", "tagline", "disqusShortname", "soundsEnabled", "animationsEnabled", "resetEveryAmount", "resetEvery", "displayPerksValue", "sortPerksByPopularity", "sounds", "animationColors"]

    @field_validator('reset_every')
    def reset_every_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('Day', 'Hour', 'Month', 'Never', 'Year'):
            raise ValueError("must be one of enum values ('Day', 'Hour', 'Month', 'Never', 'Year')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of CreateCrowdfundAppRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # set to None if title (nullable) is None
        # and model_fields_set contains the field
        if self.title is None and "title" in self.model_fields_set:
            _dict['title'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if enabled (nullable) is None
        # and model_fields_set contains the field
        if self.enabled is None and "enabled" in self.model_fields_set:
            _dict['enabled'] = None

        # set to None if enforce_target_amount (nullable) is None
        # and model_fields_set contains the field
        if self.enforce_target_amount is None and "enforce_target_amount" in self.model_fields_set:
            _dict['enforceTargetAmount'] = None

        # set to None if start_date (nullable) is None
        # and model_fields_set contains the field
        if self.start_date is None and "start_date" in self.model_fields_set:
            _dict['startDate'] = None

        # set to None if end_date (nullable) is None
        # and model_fields_set contains the field
        if self.end_date is None and "end_date" in self.model_fields_set:
            _dict['endDate'] = None

        # set to None if target_currency (nullable) is None
        # and model_fields_set contains the field
        if self.target_currency is None and "target_currency" in self.model_fields_set:
            _dict['targetCurrency'] = None

        # set to None if target_amount (nullable) is None
        # and model_fields_set contains the field
        if self.target_amount is None and "target_amount" in self.model_fields_set:
            _dict['targetAmount'] = None

        # set to None if custom_css_link (nullable) is None
        # and model_fields_set contains the field
        if self.custom_css_link is None and "custom_css_link" in self.model_fields_set:
            _dict['customCSSLink'] = None

        # set to None if main_image_url (nullable) is None
        # and model_fields_set contains the field
        if self.main_image_url is None and "main_image_url" in self.model_fields_set:
            _dict['mainImageUrl'] = None

        # set to None if embedded_css (nullable) is None
        # and model_fields_set contains the field
        if self.embedded_css is None and "embedded_css" in self.model_fields_set:
            _dict['embeddedCSS'] = None

        # set to None if perks_template (nullable) is None
        # and model_fields_set contains the field
        if self.perks_template is None and "perks_template" in self.model_fields_set:
            _dict['perksTemplate'] = None

        # set to None if notification_url (nullable) is None
        # and model_fields_set contains the field
        if self.notification_url is None and "notification_url" in self.model_fields_set:
            _dict['notificationUrl'] = None

        # set to None if tagline (nullable) is None
        # and model_fields_set contains the field
        if self.tagline is None and "tagline" in self.model_fields_set:
            _dict['tagline'] = None

        # set to None if disqus_shortname (nullable) is None
        # and model_fields_set contains the field
        if self.disqus_shortname is None and "disqus_shortname" in self.model_fields_set:
            _dict['disqusShortname'] = None

        # set to None if sounds_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.sounds_enabled is None and "sounds_enabled" in self.model_fields_set:
            _dict['soundsEnabled'] = None

        # set to None if animations_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.animations_enabled is None and "animations_enabled" in self.model_fields_set:
            _dict['animationsEnabled'] = None

        # set to None if reset_every_amount (nullable) is None
        # and model_fields_set contains the field
        if self.reset_every_amount is None and "reset_every_amount" in self.model_fields_set:
            _dict['resetEveryAmount'] = None

        # set to None if reset_every (nullable) is None
        # and model_fields_set contains the field
        if self.reset_every is None and "reset_every" in self.model_fields_set:
            _dict['resetEvery'] = None

        # set to None if display_perks_value (nullable) is None
        # and model_fields_set contains the field
        if self.display_perks_value is None and "display_perks_value" in self.model_fields_set:
            _dict['displayPerksValue'] = None

        # set to None if sort_perks_by_popularity (nullable) is None
        # and model_fields_set contains the field
        if self.sort_perks_by_popularity is None and "sort_perks_by_popularity" in self.model_fields_set:
            _dict['sortPerksByPopularity'] = None

        # set to None if sounds (nullable) is None
        # and model_fields_set contains the field
        if self.sounds is None and "sounds" in self.model_fields_set:
            _dict['sounds'] = None

        # set to None if animation_colors (nullable) is None
        # and model_fields_set contains the field
        if self.animation_colors is None and "animation_colors" in self.model_fields_set:
            _dict['animationColors'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of CreateCrowdfundAppRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "appName": obj.get("appName"),
            "title": obj.get("title"),
            "description": obj.get("description"),
            "enabled": obj.get("enabled") if obj.get("enabled") is not None else True,
            "enforceTargetAmount": obj.get("enforceTargetAmount") if obj.get("enforceTargetAmount") is not None else False,
            "startDate": obj.get("startDate"),
            "endDate": obj.get("endDate"),
            "targetCurrency": obj.get("targetCurrency"),
            "targetAmount": obj.get("targetAmount"),
            "customCSSLink": obj.get("customCSSLink"),
            "mainImageUrl": obj.get("mainImageUrl"),
            "embeddedCSS": obj.get("embeddedCSS"),
            "perksTemplate": obj.get("perksTemplate"),
            "notificationUrl": obj.get("notificationUrl"),
            "tagline": obj.get("tagline"),
            "disqusShortname": obj.get("disqusShortname"),
            "soundsEnabled": obj.get("soundsEnabled") if obj.get("soundsEnabled") is not None else False,
            "animationsEnabled": obj.get("animationsEnabled") if obj.get("animationsEnabled") is not None else False,
            "resetEveryAmount": obj.get("resetEveryAmount") if obj.get("resetEveryAmount") is not None else 1,
            "resetEvery": obj.get("resetEvery") if obj.get("resetEvery") is not None else 'Never',
            "displayPerksValue": obj.get("displayPerksValue") if obj.get("displayPerksValue") is not None else False,
            "sortPerksByPopularity": obj.get("sortPerksByPopularity") if obj.get("sortPerksByPopularity") is not None else False,
            "sounds": obj.get("sounds"),
            "animationColors": obj.get("animationColors")
        })
        return _obj



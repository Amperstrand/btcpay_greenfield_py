# coding: utf-8

"""
    BTCPay Greenfield API

    A full API to use your BTCPay Server

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictBool, StrictStr
from pydantic import Field
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class StoreRateConfiguration(BaseModel):
    """
    StoreRateConfiguration
    """ # noqa: E501
    spread: Optional[StrictStr] = Field(default=None, description="A spread applies to the rate fetched in `%`. Must be `>= 0` or `<= 100`")
    preferred_source: Optional[StrictStr] = Field(default=None, description="If `isCustomerScript` is `false` affect use this source in the default's `effectiveScript`, if `isCustomerScript` is `false`, this setting is set to `null`. (See /misc/rate-sources for the available sources)", alias="preferredSource")
    is_custom_script: Optional[StrictBool] = Field(default=None, description="Whether to use `preferredSource` with default script or a custom `effectiveScript`.", alias="isCustomScript")
    effective_script: Optional[StrictStr] = Field(default=None, description="When `isCustomScript` is `true`, this represent the custom script used to calculate a currency pair's exchange rate. Else, it represent the script generated by the default rules and `preferredSource`.", alias="effectiveScript")
    __properties: ClassVar[List[str]] = ["spread", "preferredSource", "isCustomScript", "effectiveScript"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of StoreRateConfiguration from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of StoreRateConfiguration from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "spread": obj.get("spread"),
            "preferredSource": obj.get("preferredSource"),
            "isCustomScript": obj.get("isCustomScript"),
            "effectiveScript": obj.get("effectiveScript")
        })
        return _obj


